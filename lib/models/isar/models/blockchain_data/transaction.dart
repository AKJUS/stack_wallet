/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:convert';
import 'dart:math';

import 'package:decimal/decimal.dart';
import 'package:fusiondart/src/models/address.dart' as fusion_address;
import 'package:fusiondart/src/models/input.dart' as fusion_input;
import 'package:fusiondart/src/models/output.dart' as fusion_output;
import 'package:fusiondart/src/models/transaction.dart' as fusion_tx;
import 'package:isar/isar.dart';
import 'package:stackwallet/electrumx_rpc/cached_electrumx.dart';
import 'package:stackwallet/models/isar/models/blockchain_data/address.dart';
import 'package:stackwallet/models/isar/models/blockchain_data/input.dart';
import 'package:stackwallet/models/isar/models/blockchain_data/output.dart';
import 'package:stackwallet/utilities/amount/amount.dart';
import 'package:stackwallet/utilities/enums/coin_enum.dart';
import 'package:tuple/tuple.dart';

part 'transaction.g.dart';

@Collection()
class Transaction {
  Transaction({
    required this.walletId,
    required this.txid,
    required this.timestamp,
    required this.type,
    required this.subType,
    required this.amount,
    required this.amountString,
    required this.fee,
    required this.height,
    required this.isCancelled,
    required this.isLelantus,
    required this.slateId,
    required this.otherData,
    required this.inputs,
    required this.outputs,
    required this.nonce,
    required this.numberOfMessages,
  });

  Tuple2<Transaction, Address?> copyWith({
    String? walletId,
    String? txid,
    int? timestamp,
    TransactionType? type,
    TransactionSubType? subType,
    int? amount,
    String? amountString,
    int? fee,
    int? height,
    bool? isCancelled,
    bool? isLelantus,
    String? slateId,
    String? otherData,
    List<Input>? inputs,
    List<Output>? outputs,
    int? nonce,
    Id? id,
    Address? address,
    int? numberOfMessages,
  }) {
    return Tuple2(
      Transaction(
          walletId: walletId ?? this.walletId,
          txid: txid ?? this.txid,
          timestamp: timestamp ?? this.timestamp,
          type: type ?? this.type,
          subType: subType ?? this.subType,
          amount: amount ?? this.amount,
          amountString: amountString ?? this.amountString,
          fee: fee ?? this.fee,
          height: height ?? this.height,
          isCancelled: isCancelled ?? this.isCancelled,
          isLelantus: isLelantus ?? this.isLelantus,
          slateId: slateId ?? this.slateId,
          otherData: otherData ?? this.otherData,
          nonce: nonce ?? this.nonce,
          inputs: inputs ?? this.inputs,
          outputs: outputs ?? this.outputs,
          numberOfMessages: numberOfMessages ?? this.numberOfMessages)
        ..id = id ?? this.id,
      address ?? this.address.value,
    );
  }

  Id id = Isar.autoIncrement;

  @Index()
  late final String walletId;

  @Index(unique: true, composite: [CompositeIndex("walletId")])
  late final String txid;

  @Index()
  late final int timestamp;

  @enumerated
  late final TransactionType type;

  @enumerated
  late final TransactionSubType subType;

  @Deprecated("May be inaccurate for large amounts (eth for example)")
  late final int amount;

  late String? amountString;

  late final int fee;

  late final int? height;

  late final bool isCancelled;

  late bool? isLelantus;

  late final String? slateId;

  late final String? otherData;

  late final int? nonce;

  late final List<Input> inputs;

  late final List<Output> outputs;

  late final int? numberOfMessages;

  @Backlink(to: "transactions")
  final address = IsarLink<Address>();

  @ignore
  Amount? _cachedAmount;

  @ignore
  Amount get realAmount =>
      _cachedAmount ??= Amount.fromSerializedJsonString(amountString!);

  int getConfirmations(int currentChainHeight) {
    if (height == null || height! <= 0) return 0;
    return max(0, currentChainHeight - (height! - 1));
  }

  bool isConfirmed(int currentChainHeight, int minimumConfirms) {
    final confirmations = getConfirmations(currentChainHeight);
    return confirmations >= minimumConfirms;
  }

  @override
  toString() => "{ "
      "id: $id, "
      "walletId: $walletId, "
      "txid: $txid, "
      "timestamp: $timestamp, "
      "type: ${type.name}, "
      "subType: ${subType.name}, "
      "amount: $amount, "
      "amountString: $amountString, "
      "fee: $fee, "
      "height: $height, "
      "isCancelled: $isCancelled, "
      "isLelantus: $isLelantus, "
      "slateId: $slateId, "
      "otherData: $otherData, "
      "nonce: $nonce, "
      "address: ${address.value}, "
      "inputsLength: ${inputs.length}, "
      "outputsLength: ${outputs.length}, "
      "numberOfMessages: $numberOfMessages, "
      "}";

  String toJsonString() {
    final Map<String, dynamic> result = {
      "walletId": walletId,
      "txid": txid,
      "timestamp": timestamp,
      "type": type.name,
      "subType": subType.name,
      "amount": amount,
      "amountString": amountString,
      "fee": fee,
      "height": height,
      "isCancelled": isCancelled,
      "isLelantus": isLelantus,
      "slateId": slateId,
      "otherData": otherData,
      "nonce": nonce,
      "address": address.value?.toJsonString(),
      "inputs": inputs.map((e) => e.toJsonString()).toList(),
      "outputs": outputs.map((e) => e.toJsonString()).toList(),
      "numberOfMessages": numberOfMessages,
    };
    return jsonEncode(result);
  }

  static Tuple2<Transaction, Address?> fromJsonString(
    String jsonString, {
    String? overrideWalletId,
  }) {
    final json = jsonDecode(jsonString);
    final transaction = Transaction(
      walletId: overrideWalletId ?? json["walletId"] as String,
      txid: json["txid"] as String,
      timestamp: json["timestamp"] as int,
      type: TransactionType.values.byName(json["type"] as String),
      subType: TransactionSubType.values.byName(json["subType"] as String),
      amount: json["amount"] as int,
      amountString: json["amountString"] as String,
      fee: json["fee"] as int,
      height: json["height"] as int?,
      isCancelled: json["isCancelled"] as bool,
      isLelantus: json["isLelantus"] as bool?,
      slateId: json["slateId"] as String?,
      otherData: json["otherData"] as String?,
      nonce: json["nonce"] as int?,
      inputs: List<String>.from(json["inputs"] as List)
          .map((e) => Input.fromJsonString(e))
          .toList(),
      outputs: List<String>.from(json["outputs"] as List)
          .map((e) => Output.fromJsonString(e))
          .toList(),
      numberOfMessages: json["numberOfMessages"] as int,
    );
    if (json["address"] == null) {
      return Tuple2(transaction, null);
    } else {
      final address = Address.fromJsonString(json["address"] as String);
      return Tuple2(transaction, address);
    }
  }

  // Convert to fusiondart's Transaction type.
  //
  // This is bad because in the FusionWalletInterface in getTransactionsByAddress
  // we already getAllTransactions, then for each transaction here we also getTransaction
  // for each transaction again.  But the data we need--the input's value--isn't
  // here anyways.
  Future<fusion_tx.Transaction> toFusionTransaction(
      CachedElectrumX cachedElectrumX) async {
    // Initialize Fusion Dart's Transaction object.
    fusion_tx.Transaction fusionTransaction = fusion_tx.Transaction();

    // Map the Inputs and Outputs to Fusion Dart's format.
    //
    // This takes an exqcessive amount of time because we have to get the
    // transaction for each input.  We already have the transaction for each
    // input in getTransactionsByAddress, but we don't have the input's value.
    // So we have to get the transaction again here.
    fusionTransaction.Inputs = await Future.wait(inputs.map((e) async {
      // Find input amount.
      print("2 getting tx ${e.txid}");
      Map<String, dynamic> _tx = await cachedElectrumX.getTransaction(
          coin: Coin.bitcoincash,
          txHash: e.txid,
          verbose: true); // TODO is verbose needed?

      // Check if output amount is available.
      if (_tx == null) {
        throw Exception("Transaction not found for input: ${e.txid}");
      }
      if (_tx["vout"] == null) {
        throw Exception("Vout in transaction ${e.txid} is null");
      }
      if (_tx["vout"][e.vout] == null) {
        throw Exception("Vout index ${e.vout} in transaction is null");
      }
      if (_tx["vout"][e.vout]["value"] == null) {
        throw Exception("Value of vout index ${e.vout} in transaction is null");
      }

      // Assign vout value to amount.
      final value = Amount.fromDecimal(
        Decimal.parse(_tx["vout"][e.vout]["value"].toString()),
        fractionDigits: Coin.bitcoincash.decimals,
      );

      return fusion_input.Input(
        prevTxid: utf8.encode(e.txid), // TODO verify this is what we want.
        prevIndex: e.vout, // TODO verify this is what we want.
        pubKey: utf8.encode(address.value.toString()), // TODO fix public key.
        amount: value.raw.toInt(),
      );
    }).toList());

    fusionTransaction.Outputs = outputs.map((e) {
      /*
      if (e.scriptPubKey == null) {
        // TODO calculate scriptPubKey if it is null.
      }
      */

      fusion_address.DerivationPath? derivationPath;
      List<int>? pubKey;

      // Validate that we have all the required data.
      if (address.value == null) {
        // TODO calculate address if it is null.
        throw Exception(
            "address value is null for input: ${e.scriptPubKeyAddress}");
      } else {
        if (address.value!.publicKey.isEmpty || e.scriptPubKey != null) {
          pubKey = utf8.encode(e.scriptPubKey!);
          // TODO is this valid?
        } else {
          pubKey = address.value!.publicKey;
        }
        if (address.value!.derivationPath != null) {
          derivationPath = fusion_address.DerivationPath(
              address.value!.derivationPath!.toString());
        } else {
          // TODO calculate derivation path if it is null.
          /*
          throw Exception(
              "derivationPath is null for input: ${e.scriptPubKeyAddress}");
          */
        }
      }

      // TODO handle case where address.value.publicKey is empty and e.scriptPubKey is null

      return fusion_output.Output(
        addr: fusion_address.Address(
          addr: e.scriptPubKeyAddress,
          publicKey: pubKey,
          derivationPath: derivationPath,
        ),
        value: e.value,
      );
    }).toList();

    return fusionTransaction;
  }
}

// Used in Isar db and stored there as int indexes so adding/removing values
// in this definition should be done extremely carefully in production
enum TransactionType {
  // TODO: add more types before prod release?
  outgoing,
  incoming,
  sentToSelf, // should we keep this?
  unknown;
}

// Used in Isar db and stored there as int indexes so adding/removing values
// in this definition should be done extremely carefully in production
enum TransactionSubType {
  // TODO: add more types before prod release?
  none,
  bip47Notification, // bip47 payment code notification transaction flag
  mint, // firo specific
  join, // firo specific
  ethToken; // eth token
}
