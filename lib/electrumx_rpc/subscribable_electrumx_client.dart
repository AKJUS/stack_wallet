/*
 * This file is part of Stack Wallet.
 *
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:socks_socket/socks_socket.dart';
import 'package:stackwallet/electrumx_rpc/electrumx_client.dart';
import 'package:stackwallet/exceptions/json_rpc/json_rpc_exception.dart';
import 'package:stackwallet/services/event_bus/events/global/tor_connection_status_changed_event.dart';
import 'package:stackwallet/services/tor_service.dart';
import 'package:stackwallet/utilities/logger.dart';
import 'package:stackwallet/utilities/prefs.dart';

class ElectrumXSubscription {
  final StreamController<dynamic> _controller =
      StreamController(); // TODO controller params

  Stream<dynamic> get responseStream => _controller.stream;

  void addToStream(dynamic data) => _controller.add(data);
}

class SocketTask {
  SocketTask({this.completer, this.subscription});

  final Completer<dynamic>? completer;
  final ElectrumXSubscription? subscription;

  bool get isSubscription => subscription != null;
}

class SubscribableElectrumXClient {
  int _currentRequestID = 0;
  bool _isConnected = false;
  List<int> _responseData = [];
  final Map<String, SocketTask> _tasks = {};
  Timer? _aliveTimer;
  Socket? _socket;
  SOCKSSocket? _socksSocket;
  late final bool _useSSL;
  late final Duration _connectionTimeout;
  late final Duration _keepAlive;

  bool get isConnected => _isConnected;
  bool get useSSL => _useSSL;

  void Function(bool)? onConnectionStatusChanged;

  late Prefs _prefs;
  late TorService _torService;

  SubscribableElectrumXClient({
    required bool useSSL,
    required Prefs prefs,
    TorService? torService,
    this.onConnectionStatusChanged,
    Duration connectionTimeout = const Duration(seconds: 5),
    Duration keepAlive = const Duration(seconds: 10),
  }) {
    _useSSL = useSSL;
    _prefs = prefs;
    _torService = torService ?? TorService.sharedInstance;
    _connectionTimeout = connectionTimeout;
    _keepAlive = keepAlive;

    // TODO [prio=high]: Listen for TorConnectionStatusChangedEvent.
    // TODO [prio=high]: Listen for TorPreferenceChangedEvent.
  }

  factory SubscribableElectrumXClient.from({
    required ElectrumXNode node,
    required Prefs prefs,
    TorService? torService,
  }) {
    return SubscribableElectrumXClient(
      useSSL: node.useSSL,
      prefs: prefs,
      torService: torService ?? TorService.sharedInstance,
    );
  }

  // Example for returning a future which completes upon connection.
  // static Future<SubscribableElectrumXClient> from({
  //   required ElectrumXNode node,
  //   TorService? torService,
  // }) async {
  //   final client = SubscribableElectrumXClient(
  //     useSSL: node.useSSL,
  //   );
  //
  //   await client.connect(host: node.address, port: node.port);
  //
  //   return client;
  // }

  /// Connect to the server.
  ///
  /// If Tor is enabled, it will attempt to connect through Tor.
  Future<void> connect({
    required String host,
    required int port,
  }) async {
    try {
      await _socket?.close();
    } catch (_) {}

    if (!Prefs.instance.useTor) {
      await connectClearnet(host, port);
    } else {
      // If we're supposed to use Tor...
      if (_torService.status != TorConnectionStatus.connected) {
        // ... but Tor isn't running...
        if (!_prefs.torKillSwitch) {
          // ... and the killswitch isn't set, then we'll connect clearnet.
          Logging.instance.log(
            "Tor preference set but Tor not enabled, no killswitch set, connecting to ElectrumX through clearnet",
            level: LogLevel.Warning,
          );
          await connectClearnet(host, port);
        } else {
          // ... but if the killswitch is set, then let's try to start Tor.
          await _torService.start();
          // TODO [prio=low]: Attempt to restart Tor if needed.  Update Tor package for restart feature.

          // Doublecheck that Tor is running.
          if (_torService.status != TorConnectionStatus.connected) {
            // If Tor still isn't running, then we'll throw an exception.
            throw Exception(
                "Tor preference and killswitch set but Tor not enabled, not connecting to ElectrumX");
          }

          // Connect via Tor.
          await connectTor(host, port);
        }
      } else {
        // Connect via Tor.
        await connectTor(host, port);
      }
    }

    _updateConnectionStatus(true);

    _socket!.listen(
      _dataHandler,
      onError: _errorHandler,
      onDone: _doneHandler,
      cancelOnError: true,
    );

    _aliveTimer?.cancel();
    _aliveTimer = Timer.periodic(
      _keepAlive,
      (_) async => _updateConnectionStatus(await ping()),
    );
  }

  /// Connect to the server directly.
  Future<void> connectClearnet(String host, int port) async {
    try {
      Logging.instance.log(
          "SubscribableElectrumXClient.connectClearnet(): "
          "creating a socket to $host:$port (SSL $useSSL)...",
          level: LogLevel.Info);

      if (_useSSL) {
        _socket = await SecureSocket.connect(
          host,
          port,
          timeout: _connectionTimeout,
          onBadCertificate: (_) =>
              true, // TODO do not automatically trust bad certificates.
        );
      } else {
        _socket = await Socket.connect(
          host,
          port,
          timeout: _connectionTimeout,
        );
      }

      Logging.instance.log(
          "SubscribableElectrumXClient.connectClearnet(): "
          "created socket to $host:$port...",
          level: LogLevel.Info);
    } catch (e, s) {
      final String msg = "SubscribableElectrumXClient.connectClearnet: "
          "failed to connect to $host (SSL: $useSSL)."
          "\nError: $e\nStack trace: $s";
      Logging.instance.log(msg, level: LogLevel.Fatal);
      throw JsonRpcException(msg);
    }

    return;
  }

  /// Connect to the server using the Tor service.
  Future<void> connectTor(String host, int port) async {
    // Get the proxy info from the TorService.
    final proxyInfo = _torService.getProxyInfo();

    try {
      Logging.instance.log(
          "SubscribableElectrumXClient.connectTor(): "
          "creating a SOCKS socket at $proxyInfo (SSL $useSSL)...",
          level: LogLevel.Info);

      // Create a socks socket using the Tor service's proxy info.
      _socksSocket = await SOCKSSocket.create(
        proxyHost: proxyInfo.host.address,
        proxyPort: proxyInfo.port,
        sslEnabled: useSSL,
      );

      Logging.instance.log(
          "SubscribableElectrumXClient.connectTor(): "
          "created SOCKS socket at $proxyInfo...",
          level: LogLevel.Info);
    } catch (e, s) {
      final String msg = "SubscribableElectrumXClient.connectTor(): "
          "failed to create a SOCKS socket at $proxyInfo (SSL $useSSL)..."
          "\nError: $e\nStack trace: $s";
      Logging.instance.log(msg, level: LogLevel.Fatal);
      throw JsonRpcException(msg);
    }

    try {
      Logging.instance.log(
          "SubscribableElectrumXClient.connectTor(): "
          "connecting to SOCKS socket at $proxyInfo (SSL $useSSL)...",
          level: LogLevel.Info);

      await _socksSocket?.connect();

      Logging.instance.log(
          "SubscribableElectrumXClient.connectTor(): "
          "connected to SOCKS socket at $proxyInfo...",
          level: LogLevel.Info);
    } catch (e, s) {
      final String msg = "SubscribableElectrumXClient.connectTor(): "
          "failed to connect to SOCKS socket at $proxyInfo.."
          "\nError: $e\nStack trace: $s";
      Logging.instance.log(msg, level: LogLevel.Fatal);
      throw JsonRpcException(msg);
    }

    try {
      Logging.instance.log(
          "SubscribableElectrumXClient.connectTor(): "
          "connecting to $host:$port over SOCKS socket at $proxyInfo...",
          level: LogLevel.Info);

      await _socksSocket?.connectTo(host, port);

      Logging.instance.log(
          "SubscribableElectrumXClient.connectTor(): "
          "connected to $host:$port over SOCKS socket at $proxyInfo",
          level: LogLevel.Info);
    } catch (e, s) {
      final String msg = "SubscribableElectrumXClient.connectTor(): "
          "failed to connect $host over tor proxy at $proxyInfo."
          "\nError: $e\nStack trace: $s";
      Logging.instance.log(msg, level: LogLevel.Fatal);
      throw JsonRpcException(msg);
    }

    return;
  }

  /// Disconnect from the server.
  Future<void> disconnect() async {
    _aliveTimer?.cancel();
    await _socket?.close();
    await _socksSocket?.close();
    onConnectionStatusChanged = null;
  }

  /// Format JSON request string.
  String _buildJsonRequestString({
    required String method,
    required String id,
    required List<dynamic> params,
  }) {
    final paramString = jsonEncode(params);
    return '{"jsonrpc": "2.0", "id": "$id","method": "$method","params": $paramString}\r\n';
  }

  void _updateConnectionStatus(bool connectionStatus) {
    if (_isConnected != connectionStatus && onConnectionStatusChanged != null) {
      onConnectionStatusChanged!(connectionStatus);
    }
    _isConnected = connectionStatus;
  }

  void _dataHandler(List<int> data) {
    _responseData.addAll(data);

    // 0x0A is newline
    // https://electrumx-spesmilo.readthedocs.io/en/latest/protocol-basics.html
    if (data.last == 0x0A) {
      try {
        final response = jsonDecode(String.fromCharCodes(_responseData))
            as Map<String, dynamic>;
        _responseHandler(response);
      } catch (e, s) {
        Logging.instance
            .log("JsonRPC jsonDecode: $e\n$s", level: LogLevel.Error);
        rethrow;
      } finally {
        _responseData = [];
      }
    }
  }

  void _responseHandler(Map<String, dynamic> response) {
    // subscriptions will have a method in the response
    if (response['method'] is String) {
      _subscriptionHandler(response: response);
      return;
    }

    final id = response['id'] as String;
    final result = response['result'];

    _complete(id, result);
  }

  void _subscriptionHandler({
    required Map<String, dynamic> response,
  }) {
    final method = response['method'];
    switch (method) {
      case "blockchain.scripthash.subscribe":
        final params = response["params"] as List<dynamic>;
        final scripthash = params.first as String;
        final taskId = "blockchain.scripthash.subscribe:$scripthash";

        _tasks[taskId]?.subscription?.addToStream(params.last);
        break;
      case "blockchain.headers.subscribe":
        final params = response["params"];
        const taskId = "blockchain.headers.subscribe";

        _tasks[taskId]?.subscription?.addToStream(params.first);
        break;
      default:
        break;
    }
  }

  void _errorHandler(Object error, StackTrace trace) {
    _updateConnectionStatus(false);
    Logging.instance.log(
        "SubscribableElectrumXClient called _errorHandler with: $error\n$trace",
        level: LogLevel.Info);
  }

  void _doneHandler() {
    _updateConnectionStatus(false);
    Logging.instance.log("SubscribableElectrumXClient called _doneHandler",
        level: LogLevel.Info);
  }

  void _complete(String id, dynamic data) {
    if (_tasks[id] == null) {
      return;
    }

    if (!(_tasks[id]?.completer?.isCompleted ?? false)) {
      _tasks[id]?.completer?.complete(data);
    }

    if (!(_tasks[id]?.isSubscription ?? false)) {
      _tasks.remove(id);
    } else {
      _tasks[id]?.subscription?.addToStream(data);
    }
  }

  void _addTask({
    required String id,
    required Completer<dynamic> completer,
  }) {
    _tasks[id] = SocketTask(completer: completer, subscription: null);
  }

  void _addSubscriptionTask({
    required String id,
    required ElectrumXSubscription subscription,
  }) {
    _tasks[id] = SocketTask(completer: null, subscription: subscription);
  }

  Future<dynamic> _call({
    required String method,
    List<dynamic> params = const [],
  }) async {
    final completer = Completer<dynamic>();
    _currentRequestID++;
    final id = _currentRequestID.toString();

    try {
      _addTask(id: id, completer: completer);

      if (_prefs.useTor) {
        _socksSocket?.write(
          _buildJsonRequestString(
            method: method,
            id: id,
            params: params,
          ),
        );
      } else {
        _socket?.write(
          _buildJsonRequestString(
            method: method,
            id: id,
            params: params,
          ),
        );
      }

      return completer.future;
    } catch (e, s) {
      final String msg = "SubscribableElectrumXClient._call: "
          "failed to request $method with id $id."
          "\nError: $e\nStack trace: $s";
      Logging.instance.log(msg, level: LogLevel.Fatal);
      throw JsonRpcException(msg);
    }
  }

  /// Write call to socket with timeout.
  Future<dynamic> _callWithTimeout({
    required String method,
    List<dynamic> params = const [],
    Duration timeout = const Duration(seconds: 2),
  }) async {
    final completer = Completer<dynamic>();
    _currentRequestID++;
    final id = _currentRequestID.toString();

    try {
      _addTask(id: id, completer: completer);

      if (_prefs.useTor) {
        _socksSocket?.write(
          _buildJsonRequestString(
            method: method,
            id: id,
            params: params,
          ),
        );
      } else {
        _socket?.write(
          _buildJsonRequestString(
            method: method,
            id: id,
            params: params,
          ),
        );
      }

      Timer(timeout, () {
        if (!completer.isCompleted) {
          completer.completeError(
            Exception("Request \"id: $id, method: $method\" timed out!"),
          );
        }
      });

      return completer.future;
    } catch (e, s) {
      final String msg = "SubscribableElectrumXClient._callWithTimeout: "
          "failed to request $method with id $id (timeout $timeout)."
          "\nError: $e\nStack trace: $s";
      Logging.instance.log(msg, level: LogLevel.Fatal);
      throw JsonRpcException(msg);
    }
  }

  ElectrumXSubscription _subscribe({
    required String id,
    required String method,
    List<dynamic> params = const [],
  }) {
    try {
      final subscription = ElectrumXSubscription();
      _addSubscriptionTask(id: id, subscription: subscription);
      _currentRequestID++;

      if (_prefs.useTor) {
        _socksSocket?.write(
          _buildJsonRequestString(
            method: method,
            id: id,
            params: params,
          ),
        );
      } else {
        _socket?.write(
          _buildJsonRequestString(
            method: method,
            id: id,
            params: params,
          ),
        );
      }

      return subscription;
    } catch (e, s) {
      final String msg = "SubscribableElectrumXClient._subscribe: "
          "failed to subscribe to $method with id $id."
          "\nError: $e\nStack trace: $s";
      Logging.instance.log(msg, level: LogLevel.Fatal);
      throw JsonRpcException(msg);
    }
  }

  /// Ping the server to ensure it is responding
  ///
  /// Returns true if ping succeeded
  Future<bool> ping() async {
    try {
      final response = (await _callWithTimeout(method: "server.ping")) as Map;
      return response.keys.contains("result") && response["result"] == null;
    } catch (_) {
      return false;
    }
  }

  /// Subscribe to a scripthash to receive notifications on status changes
  ElectrumXSubscription subscribeToScripthash({required String scripthash}) {
    return _subscribe(
      id: 'blockchain.scripthash.subscribe:$scripthash',
      method: 'blockchain.scripthash.subscribe',
      params: [scripthash],
    );
  }

  /// Subscribe to block headers to receive notifications on new blocks found
  ///
  /// Returns the existing subscription if found
  ElectrumXSubscription subscribeToBlockHeaders() {
    return _tasks["blockchain.headers.subscribe"]?.subscription ??
        _subscribe(
          id: "blockchain.headers.subscribe",
          method: "blockchain.headers.subscribe",
          params: [],
        );
  }
}
