// /*
//  * This file is part of Stack Wallet.
//  *
//  * Copyright (c) 2023 Cypher Stack
//  * All Rights Reserved.
//  * The code is distributed under GPLv3 license, see LICENSE file for details.
//  * Generated by Cypher Stack on 2023-05-26
//  *
//  */
//
// import 'dart:async';
//
// import 'package:ethereum_addresses/ethereum_addresses.dart';
// import 'package:flutter/widgets.dart';
// import 'package:http/http.dart';
// import 'package:isar/isar.dart';
// import 'package:stackwallet/db/isar/main_db.dart';
// import 'package:stackwallet/dto/ethereum/eth_token_tx_dto.dart';
// import 'package:stackwallet/dto/ethereum/eth_token_tx_extra_dto.dart';
// import 'package:stackwallet/models/balance.dart';
// import 'package:stackwallet/models/isar/models/isar_models.dart';
// import 'package:stackwallet/models/node_model.dart';
// import 'package:stackwallet/models/paymint/fee_object_model.dart';
// import 'package:stackwallet/services/ethereum/ethereum_api.dart';
// import 'package:stackwallet/services/event_bus/events/global/updated_in_background_event.dart';
// import 'package:stackwallet/services/event_bus/events/global/wallet_sync_status_changed_event.dart';
// import 'package:stackwallet/services/event_bus/global_event_bus.dart';
// import 'package:stackwallet/services/mixins/eth_token_cache.dart';
// import 'package:stackwallet/services/node_service.dart';
// import 'package:stackwallet/services/transaction_notification_tracker.dart';
// import 'package:stackwallet/utilities/amount/amount.dart';
// import 'package:stackwallet/utilities/default_nodes.dart';
// import 'package:stackwallet/utilities/enums/coin_enum.dart';
// import 'package:stackwallet/utilities/enums/fee_rate_type_enum.dart';
// import 'package:stackwallet/utilities/eth_commons.dart';
// import 'package:stackwallet/utilities/extensions/extensions.dart';
// import 'package:stackwallet/utilities/extensions/impl/contract_abi.dart';
// import 'package:stackwallet/utilities/flutter_secure_storage_interface.dart';
// import 'package:stackwallet/utilities/logger.dart';
// import 'package:stackwallet/wallets/models/tx_data.dart';
// import 'package:stackwallet/wallets/wallet/impl/ethereum_wallet.dart';
// import 'package:tuple/tuple.dart';
// import 'package:web3dart/web3dart.dart' as web3dart;
//
// class EthTokenWallet extends ChangeNotifier   {
//   final EthereumWallet ethWallet;
//   final TransactionNotificationTracker tracker;
//
//
//   Future<void> updateSentCachedTxData(Map<String, dynamic> txData) async {
//     final txid = txData["txid"] as String;
//     final addressString = checksumEthereumAddress(txData["address"] as String);
//     final response = await EthereumAPI.getEthTransactionByHash(txid);
//
//     final transaction = Transaction(
//       walletId: ethWallet.walletId,
//       txid: txid,
//       timestamp: DateTime.now().millisecondsSinceEpoch ~/ 1000,
//       type: TransactionType.outgoing,
//       subType: TransactionSubType.ethToken,
//       // precision may be lost here hence the following amountString
//       amount: (txData["recipientAmt"] as Amount).raw.toInt(),
//       amountString: (txData["recipientAmt"] as Amount).toJsonString(),
//       fee: (txData["fee"] as Amount).raw.toInt(),
//       height: null,
//       isCancelled: false,
//       isLelantus: false,
//       otherData: tokenContract.address,
//       slateId: null,
//       nonce: (txData["nonce"] as int?) ??
//           response.value?.nonce.toBigIntFromHex.toInt(),
//       inputs: [],
//       outputs: [],
//       numberOfMessages: null,
//     );
//
//     Address? address = await ethWallet.mainDB.getAddress(
//       ethWallet.walletId,
//       addressString,
//     );
//
//     address ??= Address(
//       walletId: ethWallet.walletId,
//       value: addressString,
//       publicKey: [],
//       derivationIndex: -1,
//       derivationPath: null,
//       type: AddressType.ethereum,
//       subType: AddressSubType.nonWallet,
//     );
//
//     await ethWallet.mainDB.addNewTransactionData(
//       [
//         Tuple2(transaction, address),
//       ],
//       ethWallet.walletId,
//     );
//   }
//
//
//
//   bool get isRefreshing => _refreshLock;
//
//   bool _refreshLock = false;
//
//   Future<void> refresh() async {
//     if (!_refreshLock) {
//       _refreshLock = true;
//       try {
//         GlobalEventBus.instance.fire(
//           WalletSyncStatusChangedEvent(
//             WalletSyncStatus.syncing,
//             ethWallet.walletId + tokenContract.address,
//             coin,
//           ),
//         );
//
//         await refreshCachedBalance();
//         await _refreshTransactions();
//       } catch (e, s) {
//         Logging.instance.log(
//           "Caught exception in ${tokenContract.name} ${ethWallet.info.name} ${ethWallet.walletId} refresh(): $e\n$s",
//           level: LogLevel.Warning,
//         );
//       } finally {
//         _refreshLock = false;
//         GlobalEventBus.instance.fire(
//           WalletSyncStatusChangedEvent(
//             WalletSyncStatus.synced,
//             ethWallet.walletId + tokenContract.address,
//             coin,
//           ),
//         );
//         notifyListeners();
//       }
//     }
//   }
//
//
//
//   Future<List<Transaction>> get transactions => ethWallet.mainDB
//       .getTransactions(ethWallet.walletId)
//       .filter()
//       .otherDataEqualTo(tokenContract.address)
//       .sortByTimestampDesc()
//       .findAll();
//
//
//
//
//
// }
